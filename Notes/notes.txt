When creating namespaces, use imperative command instead of declarative

kubectl create ns demo
kubectl scale --replicas=3 deploy/demo -n namespace

to get the endpoint of the pod
cat /etc/resolv.conf


Taints and Toleration
	- in pods you need to specify the taints you put into nodes so that it can deploy on the nodes it needs to be put. For example with AI workloads we need a gpu so we put a taints on the node (the bigger one) like gpu = true
	- and when we create a pod we need to specify that the pod will tolerate the gpu=true so that it will be deploy on the node that has GPU.
	- Syntax
		○ kubectl taint node <name> key:value:effect [NoSchedule, NoExecute, PreferNoSchedule]
		○ to untaint just add "-" on the end

Labeling the node
	- kubectl label node <name> key=value
	- for removing the label you just omit the value and add trailing hyphen(-)

To show the labels
	- kubectl node <name> --show-labels

For more strict and accurate deployment of pods it's recommended to use both taint & tolerations and node affinity


openssl genrsa -o vanj.key 2048
openssl req -new -key vanj.key -out vanj.csr -subj "//CN=vanj"
cat ./vanj.csr | base64 | tr -d "\n"
kubectl get csr vanj-csr -o jsonpath='{.status.certificate}' | base64 -d > vanj.crt	

===========================================

Service
	- ClusterIP
	- LoadBalancer
	- NodePort
DaemonSet
Taints & Toleration
Node Affinity
nodeSelectors


Metric server
HPA
Service Account
Roles and Binding including cluster
Certificates and CSR
Kubeconfig
Service Account
imagePullSecrets
calico

===========================



# Install VPA CRDs and components
kubectl apply -f https://raw.githubusercontent.com/kubernetes/autoscaler/master/vertical-pod-autoscaler/deploy/vpa-v1-crd-gen.yaml
kubectl apply -f https://raw.githubusercontent.com/kubernetes/autoscaler/master/vertical-pod-autoscaler/deploy/vpa-rbac.yaml
kubectl apply -f https://raw.githubusercontent.com/kubernetes/autoscaler/master/vertical-pod-autoscaler/deploy/recommender-deployment.yaml
kubectl apply -f https://raw.githubusercontent.com/kubernetes/autoscaler/master/vertical-pod-autoscaler/deploy/updater-deployment.yaml
kubectl apply -f https://raw.githubusercontent.com/kubernetes/autoscaler/master/vertical-pod-autoscaler/deploy/admission-controller-deployment.yaml


# Generate CA
openssl genrsa -out ca.key 2048
openssl req -x509 -new -nodes -key ca.key -subj "//CN=vpa-webhook.kube-system.svc" -days 365 -out caCert.pem

# Generate server key
openssl genrsa -out serverKey.pem 2048

# Generate server CSR
openssl req -new -key serverKey.pem -subj "//CN=vpa-webhook.kube-system.svc" -out server.csr

# Create config
cat > csr.conf <<EOF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names
[alt_names]
DNS.1 = vpa-webhook
DNS.2 = vpa-webhook.kube-system
DNS.3 = vpa-webhook.kube-system.svc
EOF

# Sign the certificate
openssl x509 -req -in server.csr -CA caCert.pem -CAkey ca.key -CAcreateserial -out serverCert.pem -days 365 -extensions v3_req -extfile csr.conf

# Create secret with correct filenames
kubectl create secret generic vpa-tls-certs \
  --from-file=caCert.pem=caCert.pem \
  --from-file=serverCert.pem=serverCert.pem \
  --from-file=serverKey.pem=serverKey.pem \
  -n kube-system

# Clean up
rm ca.key caCert.pem ca.srl serverKey.pem server.csr serverCert.pem csr.conf
